/*
  ==============================================================================

    ValleyParameter.h
    Created: 1 Jan 2014 9:01:17pm
    Author:  Nik Reiman

  ==============================================================================
*/

#ifndef VALLEYPARAMETER_H_INCLUDED
#define VALLEYPARAMETER_H_INCLUDED

#include "PluginParameters.h"

using namespace teragon;

class ValleyParameter : public FloatParameter {
public:
    ValleyParameter(const ParameterString &inName) :
    FloatParameter(inName, 0.0, 100.0, 0.0) {}

    virtual ~ValleyParameter() {}

    /**
     * Use a polynomial curve to generate frequency values for this parameter,
     * which otherwise is just a regular {0-100} float parameter. The reason that
     * this class exists (instead of using the regular FrequencyParameter which
     * also provides logarithmic scaling) is that the logarithmic curve generated
     * by FrequencyParameter does not work well with the ranges required by this
     * plugin.
     *
     * The valley size starts at 0Hz, unlike most filters or oscillators which use
     * FrequencyParameter. This means that the standard exponential curve does not
     * work very well, since the first half of the knob rotation covers just a few
     * Hertz, and then the second half rapidly covers the rest. Likewise, a linear
     * relationship is equally bad, since the first "tick" of the knob will be
     * several hundred Hertz, which causes an audible click when the filter is
     * applied.
     *
     * Therefore, a custom curve is used here, which was generated by a 5th-degree
     * polynomial. This means that the base frequency can easily be 0, and the curve
     * can be forced to cover certain key frequencies which correlate to real-world
     * use of this plugin.
     */
    virtual const ParameterValue getValue() const {
        const ParameterValue x = Parameter::getValue();
        return (x         * kA1) +
               (pow(x, 2) * kA2) +
               (pow(x, 3) * kA3) +
               (pow(x, 4) * kA4) +
               (pow(x, 5) * kA5);
    }

    virtual const ParameterString getDisplayText() const {
        if(getValue() >= 1000.0) {
            std::stringstream numberFormatter;
            numberFormatter.precision(getDisplayPrecision());
            numberFormatter << std::fixed << getValue() / 1000.0;
            return numberFormatter.str() + " kHz";
        }
        else {
            std::stringstream numberFormatter;
            numberFormatter.precision(getDisplayPrecision());
            numberFormatter << std::fixed << getValue();
            return numberFormatter.str() + " Hz";
        }
    }

private:
    /**
     * Coefficients for a 5th-degree polynomial, which was derived by interpolating
     * a curve with the following properties:
     * x = 0   -> y = 0Hz
     * x = 1   -> y = 50Hz
     * x = 50  -> y = 2500Hz
     * x = 100 -> y = 20000Hz
     * The maximum frequency of 20kHz was chosen to be intentionally beneath the
     * Nyquist frequency, given a standard sample rate of 44.1kHz. This gives the
     * filter a bit of "headroom", however it means that at the maximum valley size
     * some sound will still "leak" through on the lower end. IMHO this isn't such
     * a big deal, given that this filter was designed to be used in combination
     * with other filters, it's not a one-size-fits-all solution.
     */
    const ParameterValue kA1 = 8.0378e-10;
    const ParameterValue kA2 = 4.1982e-7;
    const ParameterValue kA3 = 1.7985e-5;
    const ParameterValue kA4 = 5.9946e-4;
    const ParameterValue kA5 = -3.9964e-6;
};

#endif  // VALLEYPARAMETER_H_INCLUDED
